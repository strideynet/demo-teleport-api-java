/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import java.io.File;
import java.util.logging.Logger;

import io.grpc.ManagedChannel;
import io.grpc.netty.shaded.io.grpc.netty.GrpcSslContexts;
import io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder;
import io.grpc.netty.shaded.io.netty.handler.ssl.ApplicationProtocolConfig;
import io.grpc.netty.shaded.io.netty.handler.ssl.ApplicationProtocolNames;
import io.grpc.netty.shaded.io.netty.handler.ssl.SslContext;
import proto.AuthServiceGrpc;
import proto.AuthServiceGrpc.AuthServiceBlockingStub;
import proto.Authservice.PingRequest;
import proto.Authservice.PingResponse;
import teleport.header.v1.MetadataOuterClass.Metadata;
import teleport.machineid.v1.BotServiceGrpc;
import teleport.machineid.v1.BotOuterClass.BotOrBuilder;
import teleport.machineid.v1.BotServiceGrpc.BotServiceBlockingStub;
import teleport.machineid.v1.BotServiceOuterClass.CreateBotRequest;
import teleport.machineid.v1.BotServiceOuterClass.UpsertBotRequest;

public class App {
    private static final Logger logger = Logger.getLogger(App.class.getName());

    public static String toHexString(String input) {
        StringBuilder hexString = new StringBuilder();
        for (char ch : input.toCharArray()) {
            hexString.append(String.format("%02x", (int) ch));
        }
        return hexString.toString();
    }

    public static void main(String[] args) throws Exception{
        String tlsCertPath = "./tbot-user/tlscert";
        String tlsKeyPath = "./tbot-user/key";
        String tlsCAPath = "./tbot-user/teleport-host-ca.crt";
        String teleportClusterAddress = "noah.teleport.sh";
        String teleportClusterName = "noah.teleport.sh";

        // Encode the cluster name to hex as this is used for SNI and ALPN.
        String encodedClusterName = toHexString(teleportClusterName);

  
        // Setup TLS
        SslContext sslContext = GrpcSslContexts.forClient()
            .keyManager(new File(tlsCertPath), new File(tlsKeyPath))
            .trustManager(new File(tlsCAPath))
            // We need to set the ALPN to a custom value to ensure that our 
            // connection is routed through the Teleport proxy and through to
            // the Auth gRPC service.
            .applicationProtocolConfig(new ApplicationProtocolConfig(
                ApplicationProtocolConfig.Protocol.ALPN,
                // TODO: Double check these behaviours.
                ApplicationProtocolConfig.SelectorFailureBehavior.NO_ADVERTISE,
                ApplicationProtocolConfig.SelectedListenerFailureBehavior.ACCEPT,
                // Set the custom Teleport ALPN first:
                String.format("teleport-auth@%s.teleport.cluster.local", encodedClusterName),
                // Then fall through to the `h2` ALPN.
                ApplicationProtocolNames.HTTP_2
            ))

            .build();

        ManagedChannel channel = NettyChannelBuilder.forAddress(teleportClusterAddress, 443)
            .sslContext(sslContext)
            .overrideAuthority(String.format("%s.teleport.cluster.local", encodedClusterName))
            .build();

        // Simple pinging of the auth server.
        logger.info("Pinging auth server");
        AuthServiceBlockingStub authClient = AuthServiceGrpc.newBlockingStub(channel);
        PingResponse res = authClient.ping(PingRequest.newBuilder().build());
        logger.info("Pinged auth server, it reported its cluster name as:" + res.getClusterName());

        BotServiceBlockingStub botClient = BotServiceGrpc.newBlockingStub(channel);

        UpsertBotRequest.Builder botRequestBuilder = UpsertBotRequest.newBuilder();
        botRequestBuilder.getBotBuilder()
            .setKind("bot")
            .setVersion("v1");
        botRequestBuilder.getBotBuilder().getMetadataBuilder()
            .setName("my-java-bot");
        botRequestBuilder.getBotBuilder().getSpecBuilder()
            .addRoles("editor");

        logger.info("Upserting bot");
        botClient.upsertBot(botRequestBuilder.build());
    }
}
